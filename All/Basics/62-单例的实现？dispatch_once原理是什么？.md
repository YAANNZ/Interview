
### dispatch_once原理
* 内部有一个静态变量作为标示，执行一次后不再执行。
* 执行的时候会上锁，防止多线程不安全的问题。

[参考](https://www.jianshu.com/p/6f5f832536ce)

### dispatch_once单例的死锁
> 死锁方式1：<br>
1、某线程T1()调用单例A，且为应用生命周期内首次调用，需要使用dispatch_once(&token, block())初始化单例。<br>
2、上述block()中的某个函数调用了dispatch_sync_safe，同步在T2线程执行代码<br>
3、T2线程正在执行的某个函数需要调用到单例A，将会再次调用dispatch_once。<br>
4、这样T1线程在等block执行完毕，它在等待T2线程执行完毕，而T2线程在等待T1线程的dispatch_once执行完毕，造成了相互等待，故而死锁

>死锁方式2：<br>
1、某线程T1()调用单例A，且为应用生命周期内首次调用，需要使用dispatch_once(&token, block())初始化单例；<br>
2、block中可能掉用到了B流程，B流程又调用了C流程，C流程可能调用到了单例A，将会再次调用dispatch_once；<br>
3、这样又造成了相互等待。

### 如何避免死锁
1. 初始化要尽量简单，不要太复杂；
2. 尽量能保持自给自足，减少对别的模块或者类的依赖；
3. 单例尽量考虑使用场景，不要随意实现单例，否则这些单例一旦初始化就会一直占着资源不能释放，造成大量的资源浪费。

[参考](https://www.jianshu.com/p/2677f3ad0014)

